import os
import time
import sys
import clr
import numpy as np
import sys
from itertools import combinations
import pythonnet
import time
import clr
import os
import matplotlib.pyplot as plt
import pandas as pd

from TimeTagger import (
    createTimeTagger,
    Countrate,
    Coincidences,
    ChannelEdge,
    SynchronizedMeasurements,
    Correlation,
    freeTimeTagger,
)

clr.AddReference("C:\\Program Files\\Thorlabs\\Kinesis\\Thorlabs.MotionControl.DeviceManagerCLI.dll")
clr.AddReference("C:\\Program Files\\Thorlabs\\Kinesis\\Thorlabs.MotionControl.GenericMotorCLI.dll")
clr.AddReference("C:\\Program Files\\Thorlabs\\Kinesis\\ThorLabs.MotionControl.KCube.InertialMotorCLI.dll")
from Thorlabs.MotionControl.DeviceManagerCLI import *
from Thorlabs.MotionControl.GenericMotorCLI import *
from Thorlabs.MotionControl.KCube.InertialMotorCLI import *
from System import Decimal  # necessary for real world units

# Add References to .NET libraries
clr.AddReference("C:\\Program Files\\Thorlabs\\Kinesis\\Thorlabs.MotionControl.DeviceManagerCLI.dll")
clr.AddReference("C:\\Program Files\\Thorlabs\\Kinesis\\Thorlabs.MotionControl.GenericMotorCLI.dll")
clr.AddReference("C:\\Program Files\\Thorlabs\\Kinesis\\ThorLabs.MotionControl.KCube.StepperMotorCLI.dll")
from Thorlabs.MotionControl.DeviceManagerCLI import *
from Thorlabs.MotionControl.GenericMotorCLI import *
from Thorlabs.MotionControl.KCube.StepperMotorCLI import *
from System import Decimal  # necessary for real world units




def piezo():
    """The main entry point for the application"""

    # Uncomment this line if you are using
    SimulationManager.Instance.InitializeSimulations()

    try:

        DeviceManagerCLI.BuildDeviceList()

        # create new device
        serial_no = "97251335"  # Replace this line with your device's serial number

        device = KCubeInertialMotor.CreateKCubeInertialMotor(serial_no)

        # Connect
        device.Connect(serial_no)
        time.sleep(0.25)


        # Ensure that the device settings have been initialized
        if not device.IsSettingsInitialized():
            device.WaitForSettingsInitialized(10000)  # 10 second timeout
            assert device.IsSettingsInitialized() is True

        # Get Device Information and display description
        device_info = device.GetDeviceInfo()
        print(device_info.Description)
        # Start polling and enable channel
        device.StartPolling(250)  #250ms polling rate
        time.sleep(0.25)
        device.EnableDevice()
        time.sleep(0.25)  # Wait for device to enable

        # Load any configuration settings needed by the controller/stage
        inertial_motor_config = device.GetInertialMotorConfiguration(serial_no)

        # Get parameters related to homing/zeroing/moving
        device_settings = ThorlabsInertialMotorSettings.GetSettings(inertial_motor_config)

        # Step parameters for an intertial motor channel
        chan1 = InertialMotorStatus.MotorChannels.Channel1  # enum chan ident
        device_settings.Drive.Channel(chan1).StepRate = 500
        device_settings.Drive.Channel(chan1).StepAcceleration = 100000

        # Send settings to the device
        device.SetSettings(device_settings, True, True)

        # Home or Zero the device (if a motor/piezo)
        # print("Zeroing device")
        # device.SetPositionAs(chan1, 0)

        # Move the device to a new position
        # new_pos = int(2000)
        # device.MoveTo(chan1, int(new_pos), 60000)  # 60 second timeout


        # Stop Polling and Disconnect
        # device.StopPolling()
        # device.Disconnect()

    except Exception as e:
        print(e)

    # # Uncomment this line if you are using Simulations
    # SimulationManager.Instance.UninitializeSimulations()
    # ...
    return device, chan1



def stepper():
    """The main entry point for the application"""

    # Uncomment this line if you are using
    SimulationManager.Instance.InitializeSimulations()

    try:

        DeviceManagerCLI.BuildDeviceList()

        # create new device
        serial_no = "26006078"  # Replace this line with your device's serial number
        device = KCubeStepper.CreateKCubeStepper(serial_no)

        # Connect
        device.Connect(serial_no)
        time.sleep(0.25)  # wait statements are important to allow settings to be sent to the device

        # Get Device Information and display description
        device_info = device.GetDeviceInfo()
        print(device_info.Description)

        # Start polling and enable
        device.StartPolling(250)  #250ms polling rate
        time.sleep(0.25)
        device.EnableDevice()
        time.sleep(0.25)  # Wait for device to enable

        # Configure device#
        use_file_settings = DeviceConfiguration.DeviceSettingsUseOptionType.UseFileSettings
        device_config = device.LoadMotorConfiguration(device.DeviceID, use_file_settings)
        # Get homing settings
        home_params = device.GetHomingParams()
        print(f'Homing Velocity: {home_params.Velocity}')

        # # Home device
        # print("Homing Motor...")
        # device.Home(60000)  # 60 seconds
        # print("Motor Homed.")

        # Get/Set Velocity Params
        device_vel_params = device.GetVelocityParams()

        print(f'Acceleration: {device_vel_params.Acceleration}',
              f'Velocity: {device_vel_params.MaxVelocity}')

        # Set a position and move it
        # new_pos = Decimal(5.0)  # in Real Units (imm)
        # device.MoveTo(new_pos, 60000)

        # Stop Polling and Disconnect
        # device.StopPolling()
        # device.Disconnect()
    except Exception as e:
        print(e)

    # # Uncomment this line if you are using Simulations
    # SimulationManager.Instance.UninitializeSimulations()
    # ...
    return device

def move_stepper(device,position):
        new_pos = Decimal(position)  # in Real Units (mm)
        device.MoveTo(new_pos, 60000)

def move_piezo(device, chan1, position):
    device.MoveTo(chan1, int(position), 60000)

def home_stepper(device):
        print("Homing Motor...")
        device.Home(60000)  # 60 seconds
        print("Motor Homed.")

def zero_piezo(device, chan1):
        print("Zeroing device")
        device.SetPositionAs(chan1, 0)


horizontal_range = 5 #mm
vertical_range = 5 #mm
horizontal_step = 0.1 #mm
vertical_step_units = 2000 # one step is about 50 nm
measurement_time_s = 10 #sec

h_pos_start = 1 #mm

h_pos = np.arange(h_pos_start, h_pos_start+5+horizontal_step, horizontal_step)
v_pos = np.arange (0, int(vertical_range * 10000)+ vertical_step_units, vertical_step_units)
results=[]

#---------------------------------------------------------------
#---------------------------------------------------------------
# --- TimeTagger setup ---
tagger = createTimeTagger()
channels = [1, 2]
for ch in channels:
    tagger.setInputDelay(ch, 0)

sync_meas = SynchronizedMeasurements(tagger)
sync_tagger = sync_meas.getTagger()

corr_list = []
for i in range(len(channels)):
    corr = Correlation(sync_tagger, channels[0], channels[i], 100, 1000)
    corr_list.append(corr)

# Start measurements and accumulate data for 1 second
sync_meas.startFor(int(10e12))  # 1 s in ps
sync_meas.waitUntilFinished()

    # Determine delays
delays = []
for corr in corr_list:
    hist_t = corr.getIndex()
    hist_c = corr.getData()

    if np.sum(hist_c) > 0:
        dt = np.sum(hist_t * hist_c) / np.sum(hist_c)
    else:
        dt = 0
    delays.append(int(dt))
print("Delays:", delays)
for ch, dt in zip(channels, delays):
    tagger.setInputDelay(ch, dt)


def measure_singles(measurement_time_s=1.0):
    with Countrate(tagger,channels) as rate:
        rate.startFor(int(measurement_time_s * 1e12))  # convert s -> ps
        rate.waitUntilFinished()
        data = rate.getData()
        ch1_cps = float(data[0])
        return [ch1_cps]
#---------------------------------------------------------------
#---------------------------------------------------------------

def main():
    piezo_device, chan1 = piezo()
    stepper_device = stepper()

    home_stepper(stepper_device)
    zero_piezo(piezo_device,chan1)
    
    for i, v in enumerate(v_pos):
        move_piezo(piezo_device,chan1, v)
        #  time.sleep(1)
        while piezo_device.isBusy:
            time.sleep(0.01)

        if i % 2==0:
            h_scan = h_pos
        else: 
            h_scan = h_pos[::-1]

        for h in h_scan:
            move_stepper(stepper_device, h)
            while stepper_device.isBusy:
                time.sleep(0.01)
            counts = measure_singles(measurement_time_s = measurement_time_s)
            results.append({
                "h_pos": h,
                "v_step": i,
                "counts":counts[0],
            })
            print(f"h={h:.2f} mm, v_step={v}, counts={counts[0]:.1f}")


    df = pd.DataFrame(results)
    save_dir_path = os.path.join(os.path.expanduser("~"), "Desktop", "scan")
    os.makedirs(save_dir_path,exist_ok=True)
    file_name = "2D_scan_results.csv"
    save_path = os.path.join(save_dir_path,file_name)
    df.to_csv(save_path,index=False)
    print(f"Saved scan results to {save_path}")

    piezo_device.StopPolling()
    stepper_device.StopPolling()
    piezo_device.Disconnect()
    stepper_device.Disconnect()
if __name__ == "__main__":
    main()
